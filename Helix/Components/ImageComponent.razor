@using Blazor.Diagrams.Components.Renderers;
@using Helix.Nodes

@inject IJSRuntime Js;

<style>
    .custom-node {
        min-width: 300px;
    }

    .custom-node .port {
        position: absolute;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background-color: #79bcdb;
        border: 3px solid #29A9E5;
        cursor: pointer;
        visibility: visible;
        transform: translate(-50%, -100%);
    }
    
    .custom-node .port.left {
        top: 50%;
        left: 0;
    }
    
    .custom-node .port.right {
        top: 50%;
        left: 100%;
    }
    
    .custom-node .port:hover, .custom-node .port.has-links {
    background-color: black;
    }
    
    .image-node {
        width: 600px;
        height: 400px;
    }
</style>

<MudCard Class="pa-8 ma-0 custom-node"
         @oncontextmenu:stopPropagation>
    <MudStack Row="true" Justify="Justify.SpaceBetween">
        <MudFileUpload T="IBrowserFile" FilesChanged="OnUploadFiles">
            <ButtonTemplate>
                <MudFab HtmlTag="label"
                        Color="Color.Secondary"
                        Icon="@Icons.Material.Filled.Image"
                        Label="Load picture"
                        for="@context"/>
            </ButtonTemplate>
        </MudFileUpload>
        <MudButton Variant="Variant.Filled"
                   @onclick="OnCopyFromClipBoard">
            Copy URL From Clipboard
        </MudButton>
    </MudStack>
    <br>
    <MudImage ObjectFit="ObjectFit.Contain" Src="@Node.Src" Class="rounded-lg image-node"/>

    @foreach (var port in Node.Ports)
    {
        <PortRenderer Port="port">
        </PortRenderer>
    }
</MudCard>

@code {

    [Parameter]
    [EditorRequired]
    public required ImageNode Node { get; set; }

    private async Task OnUploadFiles(IBrowserFile file)
    {
        await Js.InvokeVoidAsync("URL.revokeObjectURL", Node.Src);
        var dotnetImageStream = new DotNetStreamReference(file.OpenReadStream(file.Size));
        Node.Src = await Js.InvokeAsync<string>("createObjectURL_FromStream", dotnetImageStream, file.ContentType);
    }

    static readonly string[] AllowedUriSchemas = { Uri.UriSchemeHttp, Uri.UriSchemeHttps, Uri.UriSchemeFile, Uri.UriSchemeFtp, Uri.UriSchemeFtps };

    bool IsUrl(string url)
    {
        return Uri.TryCreate(url, UriKind.Absolute, out Uri? uriResult) &&
               AllowedUriSchemas.Any(x => uriResult.Scheme.Equals(x));
    }

    private async Task OnCopyFromClipBoard(MouseEventArgs obj)
    {
        var url = await Js.InvokeAsync<string>("navigator.clipboard.readText");
        if (IsUrl(url))
        {
            await Js.InvokeVoidAsync("URL.revokeObjectURL", Node.Src);
            Node.Src = url;
        }
    }

}